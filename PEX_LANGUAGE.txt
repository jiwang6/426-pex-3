// This tells SableCC to put all of the code in a package called CS426
Package CS426;

// Helpers are sets that let you talk about multiple characters in the same way
Helpers
	whitespaces = ' ' | 9 | 10 | 13;
	whole = ['1' .. '9'];
	natural = ['0' + whole];
	letter = [['a' .. 'z'] + ['A' .. 'Z']];
	
// PEX 1 - Lexer Portion
Tokens
	// Keywords
	keyword_if = 'if';
	keyword_else = 'else';
	keyword_while = 'while';
	keyword_constant = 'constant';
	keyword_function = 'function';
	keyword_main = 'main';

	// Operations and EOL
	assign = '=';
	plus = '+';
	sub = '-';
	mult = '*';
	div = '/';
	equivalent = '==';
	not_equivalent = '!=';
	greater_than = '>';
	greater_than_or_equal = '>=';
	less_than = '<';
	less_than_or_equal = '<=';
	or = '||';
	and = '&&';
	not = '!';
	eol = ';';

	// Strings
	escape_quote = '\”';
	string = '“' ([[0 .. 0xffff] - [10 + 13]])* '”';

	left_parenthesis = '(';
	right_parenthesis = ')';
	open_brace = '{';
	closed_brace = '}';
	comma = ',';

	// Comments
	comment = '//' ([[0 .. 0xffff] - [10 + 13]])*;

	// Literals
	integer = '0' | whole natural*;
	float = (('0' | natural whole*) '.' whole+) | (('0' | natural whole*) '.' whole+ 'e' '-'? natural whole*) | (('0' | natural whole*) 'e' '-'? natural whole*);

	// Variable Names
	id = '_'? ((letter+ | whole+) '_'?)+;

	// Whitespace
	blank = whitespaces+;

Ignored Tokens
	blank, comment;

// PEX 2 - Parser Portion
Productions
	program = lines; // everything is contained in 1 program
	lines = {constant} constants lines | {function} functions; // all constants and variable declarations in program must come before any function (in language spec)

	constants = keyword_constant [type]:id [varname]:id assign assignment eol;
	declare_statement = [type]:id [varname]:id eol;

	functions = {non_main} function functions | {main} main; // main() will be the last thing in the program
	function = keyword_function id left_parenthesis arguments right_parenthesis open_brace statements closed_brace;
	main = keyword_function keyword_main left_parenthesis right_parenthesis open_brace statements closed_brace; // forcing main to not have any arguments

	arguments = {no} | {yes} num_args;
	num_args = {single} argument | {multiple} num_args comma argument;
	argument = [type]:id [varname]:id;

	statements = {multiple} statement statements | {if} if_statement statements | {if_else} if_else_statement statements | {while} while_statement statements | {pass} ;
	statement = {assignment} assign_statement | {declaration} declare_statement | {call} function_call_statement;

	if_statement = keyword_if condition open_brace statements closed_brace;
	if_else_statement = keyword_if condition [if_open_brace]:open_brace [if_statements]:statements [if_closed_brace]:closed_brace keyword_else [else_open_brace]:open_brace [else_statements]:statements [else_closed_brace]:closed_brace;
	
	while_statement = keyword_while condition open_brace statements closed_brace;
	
	condition = left_parenthesis expression right_parenthesis;

	assign_statement = id assign assignment eol;
	assignment = expression;
	
	function_call_statement = id left_parenthesis parameters right_parenthesis eol;

	parameters = {no} | {yes} num_parameters;
	num_parameters = {one} parameter | {multiple} num_parameters comma parameter;
	parameter = expression;

	equivalence_comparator = {equals} equivalent | {not_equal} not_equivalent;
	great_less_comparator = {greater_than} greater_than | {less_than} less_than | {greater_than_or_equal} greater_than_or_equal | {less_than_or_equal} less_than_or_equal;

	expression = {or_comparison} expression or expression7 | {pass} expression7;
	expression7 = {and_comparison} expression7 and expression6 | {pass} expression6;
	expression6 = {equality_comparison} expression6 equivalence_comparator expression5 | {pass} expression5;
	expression5 = {greater_less_than_comparison} [first]:expression4 great_less_comparator [second]:expression4 | {pass} expression4; // don't allow chaining of boolean operations
	expression4 = {add} expression4 plus expression3 | {subtract} expression4 sub expression3 | {pass} expression3;
	expression3 = {multiply} expression3 mult expression2 | {division} expression3 div expression2 | {pass} expression2;
	expression2 = {negative} sub expression1 | {pass} expression1;
	expression1 = {parenthsis} left_parenthesis expression right_parenthesis | {pass} operand;
	operand = {string} string | {int} integer | {float} float | {variable} id;